---
title: "Final Project - Macia - 4 - Hierarchical Clustering"
author: "Maçià Bartomeu Llabrés Ferrer"
date: "2023-01-25"
output: html_document
---

We start by loading the previous "prep" file and check if the data is the same.
```{r}
df <- read.csv("FPdata_PREP.csv", stringsAsFactors = TRUE)
str(df)
summary(df)
```

```{r}
levels(df$RaceEthnicityCategory)
```


First of all we have to deal with the NA's in RaceEthnicityCategory as we kept it to avoid multicollinearity on regression models.
```{r}
print("Total row count:")
prev_rows <- nrow(df)
print(prev_rows)
print("RaceEthnicityCategory level count:")
table(df$RaceEthnicityCategory)
print("RaceEthnicityCategory level 0 - NA's %:")
prev_nas <- table(df$RaceEthnicityCategory)["0 - NA's"]
prev_nas/ prev_rows * 100
```
Usually we can replace them with the mode but as that level only represents 3% of the data and we will still be above 400.000 rows we will simply drop them.
```{r}
df <- droplevels(df[df$RaceEthnicityCategory != "0 - NA's", ])
table(df$RaceEthnicityCategory)
print(paste("Predicted rows:",prev_rows-prev_nas))
print(paste("Actual rows:   ",nrow(df)))
```
```{r}
str(df)
summary(df)
```

Since we will be doing some clustering, it’s better to normalize all the numeric variables.
```{r}
normalize <- function(x) {
  return ((x - min(x)) / (max(x) - min(x)))
}

factor_i <- which(colnames(df) == 'RaceEthnicityCategory')
df_nor <- as.data.frame(lapply(df[-c(factor_i)], normalize))
df_nor <-cbind(df_nor, df[,factor_i])
colnames(df_nor)[ncol(df_nor)] <- 'RaceEthnicityCategory'
summary(df_nor)
```

As clustering is unsupervised machine learning we need to ignore RaceEthnicityCategory. I will start with hclust and as the full dataset is to big I take small samples. But to prove the algorithm I will test every distance and agglomeration method. We have to make a little "trick", because the new sample dataset is random we need to take a look at how many ethnicities we have beforehand to assign the correct value to k.
```{r}
set.seed(123)
idx <- sample(1:dim(df_nor)[1], 50)
df_sample <- df_nor[idx,]

clusters <- length(unique(df_sample$RaceEthnicityCategory))

distances <- c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowsky")
methods <- c("complete", "average", "single", "ward.D", "ward.D2", "median", "centroid", "mcquitty")

for (i in 1:length(distances)) {
  for (j in 1:length(methods)) {
    hc <- hclust(dist(df_sample[,1:39], method="euclidean"), method=methods[[j]])
    plot(hc, hang = -1, cex = 0.75, labels=df_sample$RaceEthnicityCategory, main =
           paste("Clusters:", clusters, "Distance:", distances[[i]],"Method:",methods[[j]]))
    rect.hclust(hc, k=clusters, border = 2:(clusters+1))
  }
}
```

We can clearly see that there is no combination that groups correctly by ethnicity. This can be because the random sample we took, so lets try some others.
```{r}
for (x in 1:10) {
  set.seed(x)
  idx <- sample(1:dim(df_nor)[1], 50)
  df_sample <- df_nor[idx,]
  
  clusters <- length(unique(df_sample$RaceEthnicityCategory))
  
  distances <- c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowsky")
  methods <- c("complete", "average", "single", "ward.D", "ward.D2", "median", "centroid", "mcquitty")
  
  for (i in 1:length(distances)) {
    for (j in 1:length(methods)) {
      hc <- hclust(dist(df_sample[,1:39], method="euclidean"), method=methods[[j]])
      plot(hc, hang = -1, cex = 0.75, labels=df_sample$RaceEthnicityCategory, main =
             paste("Seed:", x, "Clusters:", clusters, "Distance:", distances[[i]],"Method:",methods[[j]]))
      rect.hclust(hc, k=clusters, border = 2:(clusters+1))
    }
  }
}
```

Once again there is no model that groups the data correctly. Before trying another approach I will try to reduce the variables just to the diseases.
```{r}
set.seed(123)
idx <- sample(1:dim(df_nor)[1], 50)
df_sample <- df_nor[idx,]

clusters <- length(unique(df_sample$RaceEthnicityCategory))

distances <- c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowsky")
methods <- c("complete", "average", "single", "ward.D", "ward.D2", "median", "centroid", "mcquitty")

for (i in 1:length(distances)) {
  for (j in 1:length(methods)) {
    hc <- hclust(dist(df_sample[,10:19], method="euclidean"), method=methods[[j]])
    plot(hc, hang = -1, cex = 0.75, labels=df_sample$RaceEthnicityCategory, main =
           paste("Clusters:", clusters, "Distance:", distances[[i]],"Method:",methods[[j]]))
    rect.hclust(hc, k=clusters, border = 2:(clusters+1))
  }
}
```

Now I will try to reduce the columns only taking into account one disease. As we see previously in the logistic regressions "HadSkinCancer" is the best candidate.

```{r}
for (i in 1:ncol(df_nor)) {
  print(paste(i,colnames(df_nor)[i]))
}
```


```{r}
set.seed(123)
idx <- sample(1:dim(df_nor)[1], 50)
df_sample <- df_nor[idx,]

clusters <- length(unique(df_sample$RaceEthnicityCategory))

distances <- c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowsky")
methods <- c("complete", "average", "single", "ward.D", "ward.D2", "median", "centroid", "mcquitty")

for (i in 1:length(distances)) {
  for (j in 1:length(methods)) {
    hc <- hclust(dist(df_sample[,-c(10:13,15:19,40)], method="euclidean"), method=methods[[j]])
    plot(hc, hang = -1, cex = 0.75, labels=df_sample$RaceEthnicityCategory, main =
           paste("Only \"HadSkinCancer\" Clusters:", clusters, "Distance:", distances[[i]],"Method:",methods[[j]]))
    rect.hclust(hc, k=clusters, border = 2:(clusters+1))
  }
}
```

After all of this we can clearly conclude hclust is not capable to separate our data by ethnicities.

As this file is getting a bit too long I will save the normalized dataset and continue with other clustering algorithms in a new file.
```{r}
write.csv(df_nor, "FPdata_NOR.csv", row.names = FALSE)
```